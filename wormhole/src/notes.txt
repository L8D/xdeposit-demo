export async function transferFromSolana(
  connection: Connection,
  bridgeAddress: string,                    // core bridge address
  tokenBridgeAddress: string,
  payerAddress: string,                     // main account of user (maybe gas is deducted from here?)
  fromAddress: string,                      // comes from Token.getAssociatedTokenAddress
  mintAddress: string,                      // comes from getForeignAssetSolana
  amount: BigInt,
  targetAddress: Uint8Array,                // address on target chain (in a format understood by target chain) see tryNativeToUint8Array(targetAddress, CHAIN_ID_ETH),
  targetChain: ChainId | ChainName,         
  originAddress?: Uint8Array,               // iff it's wrapped on solana side, this is the address of the native token (for native on sol, don't specify this)
  originChain?: ChainId | ChainName,        // iff it's wrapped on solana side, what chain is it native to (I guess this supports xfering non-native to non-native)
  fromOwnerAddress?: string,                // unknown, not provided in my example
  relayerFee: BigInt = BigInt(0),           // unknown, not provided in my example
  payload: Uint8Array | null = null         // unknown, not provided in my example
) {

/// approval looks like this in JS 

  const approvalIx = Token.createApproveInstruction(
    TOKEN_PROGRAM_ID,
    new PublicKey(fromAddress),
    new PublicKey(approval_authority_address(tokenBridgeAddress)),
    new PublicKey(fromOwnerAddress || payerAddress),
    [],
    new u64(amount.toString(16), 16)
  );

//// js sdk looks like this calling wasm

        : transfer_native_ix(
            tokenBridgeAddress,
            bridgeAddress,
            payerAddress,
            messageKey.publicKey.toString(),
            fromAddress,
            mintAddress,
            nonce,
            amount,
            relayerFee,
            targetAddress,
            coalesceChainId(targetChain)
          )

      : transfer_wrapped_ix(
          tokenBridgeAddress,
          bridgeAddress,
          payerAddress,
          messageKey.publicKey.toString(),
          fromAddress,
          fromOwnerAddress || payerAddress,
          originChainId as number, // checked by isSolanaNative
          originAddress as Uint8Array, // checked by throw
          nonce,
          amount,
          relayerFee,
          targetAddress,
          coalesceChainId(targetChain)
        )

///////////////////

pub fn transfer_native_ix(
    program_id: String,
    bridge_id: String,
    payer: String,
    message: String,
    from: String,
    mint: String,
    nonce: u32,
    amount: u64,
    fee: u64,
    target_address: Vec<u8>,
    target_chain: u16,

pub fn transfer_wrapped_ix(
    program_id: String,
    bridge_id: String,
    payer: String,
    message: String,
    from: String,
    from_owner: String,         // wrapped only
    token_chain: u16,           // wrapped only
    token_address: Vec<u8>,     // wrapped only
    nonce: u32,
    amount: u64,
    fee: u64,
    target_address: Vec<u8>,
    target_chain: u16,
) -> JsValue {


///////////  
// gameplan:  use Anchor serialization to match 

WorkflowStep {
  uint16 stepId
  Vec<u8> args
}

// args are decoded by the implementation of the step
// 1 decode wormhole args into the same args as transfer_native and transfer_wrapped in instructions.rs
// 2 copy/paste code enough to implement transfer_native_raw / transfer_wrapped_raw