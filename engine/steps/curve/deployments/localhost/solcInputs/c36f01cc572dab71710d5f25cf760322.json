{
  "language": "Solidity",
  "sources": {
    "@freemarket/core/contracts/IWorkflowStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './model/Asset.sol';\nimport './model/AssetAmount.sol';\nimport './model/WorkflowStepResult.sol';\n\ninterface IWorkflowStep {\n  function execute(\n    // input assets paired with amounts of each\n    AssetAmount[] calldata inputAssetAmounts,\n    // expected output assets (amounts not known yet)\n    Asset[] calldata outputAssets,\n    // additional arguments specific to this step\n    bytes calldata data\n  ) external payable returns (WorkflowStepResult memory);\n}\n"
    },
    "@freemarket/core/contracts/model/Asset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetType.sol';\n\nstruct Asset {\n  AssetType assetType;\n  address assetAddress; // 0x0 for ETH, the ERC20 address.  If it's an account balance, this could represent the token of the account\n}\n"
    },
    "@freemarket/core/contracts/model/AssetAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\nstruct AssetAmount {\n  Asset asset;\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/AssetType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum AssetType {\n  Native,\n  ERC20,\n  ERC721\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetAmount.sol';\n\n// The return value from the execution of a step.\nstruct WorkflowStepResult {\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmounts;\n  // The index of the next step in a workflow.\n  // This value allows the step to override the default nextStepIndex\n  // statically defined\n  // -1 means terminate the workflow\n  // -2 means do not override the statically defined nextStepIndex in WorkflowStep\n  int16 nextStepIndex;\n}\n"
    },
    "@freemarket/step-sdk/contracts/LibActionHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@freemarket/core/contracts/model/AssetType.sol\";\nimport \"@freemarket/core/contracts/model/WorkflowStepResult.sol\";\n\nlibrary LibActionHelpers {\n    function singleAssetResult(AssetType assetType, address assetAddress, uint256 amount)\n        internal\n        pure\n        returns (WorkflowStepResult memory)\n    {\n        Asset memory asset = Asset(assetType, assetAddress);\n        AssetAmount[] memory ouputAssetAmounts = new AssetAmount[](1);\n        ouputAssetAmounts[0] = AssetAmount(asset, amount);\n        return WorkflowStepResult(ouputAssetAmounts, -1);\n    }\n\n    function singleTokenResult(address assetAddress, uint256 amount)\n        internal\n        pure\n        returns (WorkflowStepResult memory)\n    {\n        return singleAssetResult(AssetType.ERC20, assetAddress, amount);\n    }\n\n    function noOutputAssetsResult() internal pure returns (WorkflowStepResult memory) {\n        return singleAssetResult(AssetType.Native, address(0), 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/CurveTriCrypto2SwapAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@freemarket/core/contracts/IWorkflowStep.sol\";\nimport \"@freemarket/step-sdk/contracts/LibActionHelpers.sol\";\nimport \"@freemarket/core/contracts/model/AssetAmount.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nstruct CurveTriCryptoSwapArgs {\n    uint256 fromIndex;\n    uint256 toIndex;\n}\n\ncontract CurveTriCrypto2SwapAction is IWorkflowStep {\n    address public immutable triCryptoAddress;\n\n    constructor(address _triCryptoAddress) {\n        triCryptoAddress = _triCryptoAddress;\n    }\n\n    function execute(AssetAmount[] calldata inputAssetAmounts, Asset[] calldata, bytes calldata)\n        public\n        payable\n        returns (WorkflowStepResult memory)\n    {\n        // // validate\n        // require(inputAssetAmounts.length == 1, \"there must be exactly 1 input asset\");\n        // require(inputAssetAmounts[0].asset.assetType == AssetType.ERC20, \"the input asset must be an ERC20\");\n        // // require(outputAssets.length == 1, 'there must be exactly 1 output asset when keeping the aToken in the engine');\n\n        // emit AaveSupplyActionEvent(inputAssetAmounts[0]);\n\n        // // approve aave to take the asset\n        // IERC20(inputAssetAmounts[0].asset.assetAddress).approve(poolAddress, inputAssetAmounts[0].amount);\n\n        // // get the aToken\n        // IAaveV3Pool pool = IAaveV3Pool(poolAddress);\n        // ReserveData memory reserveData = pool.getReserveData(inputAssetAmounts[0].asset.assetAddress);\n        // IERC20 aToken = IERC20(reserveData.aTokenAddress);\n\n        // // take note of the before balance\n        // uint256 aTokenBalanceBefore = aToken.balanceOf(address(this));\n\n        // // invoke supply\n        // pool.supply(inputAssetAmounts[0].asset.assetAddress, inputAssetAmounts[0].amount, address(this), 0);\n        // uint256 aTokenBalanceAfter = aToken.balanceOf(address(this));\n        // require(aTokenBalanceAfter > aTokenBalanceBefore, \"aToken balance did not increase\");\n\n        return LibActionHelpers.noOutputAssetsResult();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}