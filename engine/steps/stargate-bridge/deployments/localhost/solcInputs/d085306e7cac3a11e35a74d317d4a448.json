{
  "language": "Solidity",
  "sources": {
    "@freemarket/core/contracts/IWorkflowRunner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './model/AssetAmount.sol';\nimport './model/Workflow.sol';\n\ninterface IWorkflowRunner {\n  function executeWorkflow(Workflow calldata workflow) external payable;\n\n  function continueWorkflow(\n    address userAddress,\n    uint256 nonce,\n    Workflow memory workflow,\n    AssetAmount memory startingAsset\n  ) external payable;\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './model/Asset.sol';\nimport './model/AssetAmount.sol';\nimport './model/WorkflowStepResult.sol';\n\ninterface IWorkflowStep {\n  function execute(\n    // input assets paired with amounts of each\n    AssetAmount[] calldata inputAssetAmounts,\n    // expected output assets (amounts not known yet)\n    Asset[] calldata outputAssets,\n    // additional arguments specific to this step\n    bytes calldata data\n  ) external payable returns (WorkflowStepResult memory);\n}\n"
    },
    "@freemarket/core/contracts/LibActionHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './model/AssetType.sol';\nimport './model/WorkflowStepResult.sol';\n\nlibrary LibActionHelpers {\n  function singleAssetResult(AssetType assetType, address assetAddress, uint256 amount) internal pure returns (WorkflowStepResult memory) {\n    Asset memory asset = Asset(assetType, assetAddress);\n    AssetAmount[] memory ouputAssetAmounts = new AssetAmount[](1);\n    ouputAssetAmounts[0] = AssetAmount(asset, amount);\n    return WorkflowStepResult(ouputAssetAmounts, -1);\n  }\n\n  function singleTokenResult(address assetAddress, uint256 amount) internal pure returns (WorkflowStepResult memory) {\n    return singleAssetResult(AssetType.ERC20, assetAddress, amount);\n  }\n\n  function noOutputAssetsResult() internal pure returns (WorkflowStepResult memory) {\n    return singleAssetResult(AssetType.Native, address(0), 0);\n  }\n}\n"
    },
    "@freemarket/core/contracts/model/Asset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetType.sol';\n\nstruct Asset {\n  AssetType assetType;\n  address assetAddress; // 0x0 for ETH, the ERC20 address.  If it's an account balance, this could represent the token of the account\n}\n"
    },
    "@freemarket/core/contracts/model/AssetAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\nstruct AssetAmount {\n  Asset asset;\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/AssetType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum AssetType {\n  Native,\n  ERC20,\n  ERC721\n}\n"
    },
    "@freemarket/core/contracts/model/BridgePayload.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './Workflow.sol';\n\n// The payload passed form the source chain to the destination chains to continue a multi-chain workflow\nstruct BridgePayload {\n  // the end user's address on the destination chain\n  address userAddress;\n  // a (statistically) unique id to correlate the sending chain's workflow segment with the target chain's workflow segment\n  uint256 nonce;\n  // the 'continuation' workflow that executes on the target chain\n  Workflow workflow;\n}\n"
    },
    "@freemarket/core/contracts/model/Workflow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\n// an input asset to a WorkflowStep\nstruct WorkflowStepInputAsset {\n  // the input asset\n  Asset asset;\n  // the amount of the input asset\n  uint256 amount;\n  // if true 'amount' is treated as a percent, with 4 decimals of precision (1000000 represents 100%)\n  bool amountIsPercent;\n}\n\n// Parameters for a workflow step\nstruct WorkflowStep {\n  // The logical identifer of the step (e.g., 10 represents WrapEtherStep).\n  uint16 stepId;\n  // The contract address of a specific version of the action.\n  // Individual step contracts may be upgraded over time, and this allows\n  // workflows 'freeze' the version of contract for this step\n  // A value of address(0) means use the latest and greatest version  of\n  // this step based only on stepId.\n  address stepAddress;\n  // The input assets to this step.\n  WorkflowStepInputAsset[] inputAssets;\n  // The output assets for this step.\n  Asset[] outputAssets;\n  // Additional step-specific parameters for this step, typically serialized in standard abi encoding.\n  bytes data;\n  // The index of the next step in the directed graph of steps. (see the Workflow.steps array)\n  int16 nextStepIndex;\n}\n\n// The main workflow data structure.\nstruct Workflow {\n  // The nodes in the directed graph of steps.\n  // The start step is defined to be at index 0.\n  // The 'edges' in the graph are defined within each WorkflowStep,\n  // but can be overriden in the return value of a step.\n  WorkflowStep[] steps;\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetAmount.sol';\n\n// The return value from the execution of a step.\nstruct WorkflowStepResult {\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmounts;\n  // The index of the next step in a workflow.\n  // This value allows the step to override the default nextStepIndex\n  // statically defined\n  // -1 means terminate the workflow\n  // -2 means do not override the statically defined nextStepIndex in WorkflowStep\n  int16 nextStepIndex;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/BridgeBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@freemarket/core/contracts/IWorkflowStep.sol\";\n\nabstract contract BridgeBase is IWorkflowStep {\n    event WorkflowBridged(string bridgeName, uint256 targetChainId, uint256 nonce);\n}\n"
    },
    "contracts/IStargateFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\ninterface IStargateFactory {\n  function getPool(uint256) external view returns (address);\n\n  function allPools(uint256 index) external view returns (address);\n}\n"
    },
    "contracts/IStargateFeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.13;\n\nstruct SwapObj {\n  uint256 amount;\n  uint256 eqFee;\n  uint256 eqReward;\n  uint256 lpFee;\n  uint256 protocolFee;\n  uint256 lkbRemove;\n}\n\ninterface IStargateFeeLibrary {\n  function getFees(\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    uint16 _dstChainId,\n    address _from,\n    uint256 _amountSD\n  ) external view returns (SwapObj memory);\n\n  function getVersion() external view returns (string memory);\n}\n"
    },
    "contracts/IStargatePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\ninterface IStargatePool {\n  function token() external view returns (address);\n\n  function feeLibrary() external view returns (address);\n}\n"
    },
    "contracts/IStargateReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\ninterface IStargateReceiver {\n  function sgReceive(\n    uint16 _srcChainId, // the remote chainId sending the tokens\n    bytes memory _srcAddress, // the remote Bridge address\n    uint256 _nonce,\n    address _token, // the token contract on the local chain\n    uint256 amountLD, // the qty of local _token contract tokens\n    bytes memory payload\n  ) external;\n}\n"
    },
    "contracts/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.13;\n\n// abicoder v2 is enabled by default: https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html\n// pragma abicoder v2;\n\ninterface IStargateRouter {\n  function factory() external view returns (address);\n\n  struct lzTxObj {\n    uint256 dstGasForCall;\n    uint256 dstNativeAmount;\n    bytes dstNativeAddr;\n  }\n\n  function addLiquidity(\n    uint256 _poolId,\n    uint256 _amountLD,\n    address _to\n  ) external;\n\n  function swap(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLD,\n    uint256 _minAmountLD,\n    lzTxObj memory _lzTxParams,\n    bytes calldata _to,\n    bytes calldata _payload\n  ) external payable;\n\n  function redeemRemote(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLP,\n    uint256 _minAmountLD,\n    bytes calldata _to,\n    lzTxObj memory _lzTxParams\n  ) external payable;\n\n  function instantRedeemLocal(\n    uint16 _srcPoolId,\n    uint256 _amountLP,\n    address _to\n  ) external returns (uint256);\n\n  function redeemLocal(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLP,\n    bytes calldata _to,\n    lzTxObj memory _lzTxParams\n  ) external payable;\n\n  function sendCredits(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress\n  ) external payable;\n\n  function quoteLayerZeroFee(\n    uint16 _dstChainId,\n    uint8 _functionType,\n    bytes calldata _toAddress,\n    bytes calldata _transferAndCallPayload,\n    lzTxObj memory _lzTxParams\n  ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/MockStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.13;\n\nimport './IStargateRouter.sol';\n\ncontract MockStargateRouter is IStargateRouter {\n  struct MockStargateRouterSwapArgs {\n    uint16 dstChainId;\n    uint256 srcPoolId;\n    uint256 dstPoolId;\n    address payable refundAddress;\n    uint256 amount;\n    uint256 minAmountOut;\n    bytes to;\n    lzTxObj lzTxParams;\n    bytes payload;\n  }\n\n  MockStargateRouterSwapArgs[] internal swapInvocations;\n\n  function getSwapInvocations() public view returns (MockStargateRouterSwapArgs[] memory) {\n    return swapInvocations;\n  }\n\n  function getSwapInvocationAt(uint256 i) public view returns (MockStargateRouterSwapArgs memory) {\n    return swapInvocations[i];\n  }\n\n  function getSwapInvocationCount() public view returns (uint256) {\n    return swapInvocations.length;\n  }\n\n  function clear() public {\n    while (swapInvocations.length > 0) {\n      swapInvocations.pop();\n    }\n  }\n\n  function addLiquidity(\n    uint256 _poolId,\n    uint256 _amountLD,\n    address _to\n  ) external {}\n\n  function swap(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLD,\n    uint256 _minAmountLD,\n    lzTxObj memory _lzTxParams,\n    bytes calldata _to,\n    bytes calldata _payload\n  ) external payable {\n    swapInvocations.push(\n      MockStargateRouterSwapArgs(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, _amountLD, _minAmountLD, _to, _lzTxParams, _payload)\n    );\n  }\n\n  function redeemRemote(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLP,\n    uint256 _minAmountLD,\n    bytes calldata _to,\n    lzTxObj memory _lzTxParams\n  ) external payable {}\n\n  function instantRedeemLocal(\n    uint16,\n    uint256,\n    address\n  ) external pure returns (uint256) {\n    return 0;\n  }\n\n  function redeemLocal(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLP,\n    bytes calldata _to,\n    lzTxObj memory _lzTxParams\n  ) external payable {}\n\n  function sendCredits(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress\n  ) external payable {}\n\n  function quoteLayerZeroFee(\n    uint16,\n    uint8,\n    bytes calldata,\n    bytes calldata,\n    lzTxObj memory\n  ) external pure returns (uint256, uint256) {\n    return (0, 0);\n  }\n\n  function factory() external pure returns (address) {\n    return address(0);\n  }\n}\n"
    },
    "contracts/StargateBridgeAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./BridgeBase.sol\";\nimport \"@freemarket/core/contracts/LibActionHelpers.sol\";\nimport \"@freemarket/core/contracts/model/Asset.sol\";\nimport \"@freemarket/core/contracts/model/AssetAmount.sol\";\nimport \"@freemarket/core/contracts/model/BridgePayload.sol\";\nimport \"@freemarket/core/contracts/IWorkflowRunner.sol\";\nimport \"./IStargateRouter.sol\";\nimport \"./IStargateReceiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// StargateBridgeAction specific arguments\nstruct StargateBridgeActionArgs {\n    //  addr of the StargateSwapAction on the target chain.\n    address dstActionAddress;\n    // addr of the user (caller on the source chain)\n    address dstUserAddress;\n    // stargate destination chain\n    uint16 dstChainId;\n    // stargate source pool (implies source asset)\n    uint256 srcPoolId;\n    // stargate destination pool (implies destination asset)\n    uint256 dstPoolId;\n    // gas to execute workflow continuation on destination chain\n    uint256 dstGasForCall;\n    // amount of native asset to send to dstUserAddress\n    uint256 dstNativeAmount;\n    // minimum amount of output asset (else the tx on the source chain will revert)\n    uint256 minAmountOut;\n    // if true, minAmountOut passed to stargate\n    bool minAmountOutIsPercent;\n    // the abi-encoded workflow that will execute on the destination chain\n    bytes continuationWorkflow;\n    // the value used to correlate the source chain transaction with the target chain transaction\n    uint256 nonce;\n}\n\ncontract StargateBridgeAction is BridgeBase, IStargateReceiver {\n    address public immutable frontDoorAddress;\n    address public immutable stargateRouterAddress;\n\n    /// @notice This event is emitted on the destination chain when Stargate invokes our sgReceive method\n    /// @param tokenAddress the address of the erc20 that was transfered from the source chain to this chain.abi\n    /// @param bridgePayload the payload that was sent along with the erc20.\n    event SgReceiveCalled(address tokenAddress, uint256 amount, BridgePayload bridgePayload);\n\n    event StargateBridgeParamsEvent(\n        uint256 nativeAmount,\n        uint256 assetAmount,\n        address dstActionAddress,\n        uint16 dstChainId,\n        uint256 srcPoolId,\n        uint256 dstPoolId,\n        uint256 dstGasForCall,\n        uint256 dstNativeAmount,\n        uint256 minAmountOut,\n        bytes continuationWorkflow\n    );\n\n    constructor(address _frontDoorAddress, address _stargateRouterAddress) {\n        frontDoorAddress = _frontDoorAddress;\n        stargateRouterAddress = _stargateRouterAddress;\n    }\n\n    //  need to gather things up into a struct to prevent 'Stack too deep'\n    struct Locals {\n        uint256 lengthPrefix;\n        StargateBridgeActionArgs sgParams;\n        bytes dstActionAddressEncoded;\n        uint256 minAmountOut;\n        AssetAmount nativeInputAsset;\n        AssetAmount erc20InputAsset;\n    }\n\n    function execute(AssetAmount[] calldata inputAssetAmounts, Asset[] calldata, bytes calldata data)\n        public\n        payable\n        returns (WorkflowStepResult memory)\n    {\n        Locals memory locals;\n        require(inputAssetAmounts.length == 2, \"there must be 2 input assets\");\n        if (inputAssetAmounts[0].asset.assetType == AssetType.Native) {\n            require(inputAssetAmounts[1].asset.assetType == AssetType.ERC20, \"one input asset must be an ERC20\");\n            locals.nativeInputAsset = inputAssetAmounts[0];\n            locals.erc20InputAsset = inputAssetAmounts[1];\n        } else if (inputAssetAmounts[1].asset.assetType == AssetType.Native) {\n            require(inputAssetAmounts[0].asset.assetType == AssetType.ERC20, \"one input asset must be an ERC20\");\n            locals.nativeInputAsset = inputAssetAmounts[1];\n            locals.erc20InputAsset = inputAssetAmounts[0];\n        } else {\n            revert(\"one input asset must be native\");\n        }\n        require(\n            inputAssetAmounts[0].asset.assetType == AssetType.ERC20\n                || inputAssetAmounts[0].asset.assetType == AssetType.Native,\n            \"the input asset must be an ERC20 or Native\"\n        );\n\n        // approve sg to take the token\n        if (inputAssetAmounts[0].asset.assetType == AssetType.ERC20) {\n            approveErc20(inputAssetAmounts[0].asset.assetAddress, inputAssetAmounts[0].amount);\n        }\n\n        locals.sgParams = abi.decode(data, (StargateBridgeActionArgs));\n\n        // address payable refundAddress = payable(msg.sender);\n        locals.dstActionAddressEncoded = abi.encodePacked(locals.sgParams.dstActionAddress);\n        if (locals.sgParams.minAmountOutIsPercent) {\n            locals.minAmountOut = (inputAssetAmounts[0].amount * locals.sgParams.minAmountOut) / 100_000;\n        } else {\n            locals.minAmountOut = locals.sgParams.minAmountOut;\n        }\n\n        emit StargateBridgeParamsEvent(\n            locals.nativeInputAsset.amount, // native amount\n            locals.erc20InputAsset.amount, // token amount\n            locals.sgParams.dstActionAddress, // dest addr for money and sgReceive\n            locals.sgParams.dstChainId,\n            locals.sgParams.srcPoolId,\n            locals.sgParams.dstPoolId,\n            locals.sgParams.dstGasForCall,\n            locals.sgParams.dstNativeAmount,\n            locals.minAmountOut,\n            locals.sgParams.continuationWorkflow\n            );\n\n        IStargateRouter(stargateRouterAddress).swap{value: locals.nativeInputAsset.amount}(\n            locals.sgParams.dstChainId,\n            locals.sgParams.srcPoolId,\n            locals.sgParams.dstPoolId,\n            payable(msg.sender), // refundAddreess\n            locals.erc20InputAsset.amount,\n            locals.minAmountOut,\n            IStargateRouter.lzTxObj(\n                locals.sgParams.dstGasForCall,\n                locals.sgParams.dstNativeAmount,\n                abi.encodePacked(locals.sgParams.dstUserAddress)\n            ),\n            locals.dstActionAddressEncoded,\n            locals.sgParams.continuationWorkflow\n        );\n        emit WorkflowBridged(\"Stargate\", locals.sgParams.dstChainId, locals.sgParams.nonce);\n\n        return LibActionHelpers.noOutputAssetsResult();\n    }\n\n    function approveErc20(address tokenAddress, uint256 amount) internal {\n        IERC20 inputToken = IERC20(tokenAddress);\n        inputToken.approve(stargateRouterAddress, amount);\n    }\n\n    function sgReceive(\n        uint16, // the remote chainId sending the tokens\n        bytes memory, // the remote Bridge address\n        uint256, // stargate nonce, use unknown\n        address tokenAddress, // the token contract on the local chain\n        uint256 amount, // the qty of local token contract tokens\n        bytes memory payload\n    ) external {\n        require(msg.sender == stargateRouterAddress, \"only Stargate is permitted to call sgReceive\");\n        BridgePayload memory bridgePayload = abi.decode(payload, (BridgePayload));\n        emit SgReceiveCalled(tokenAddress, amount, bridgePayload);\n\n        IERC20 startingToken = IERC20(tokenAddress);\n        SafeERC20.safeTransfer(startingToken, frontDoorAddress, amount);\n\n        AssetAmount memory startingAsset = AssetAmount(Asset(AssetType.ERC20, tokenAddress), amount);\n        IWorkflowRunner runner = IWorkflowRunner(frontDoorAddress);\n        runner.continueWorkflow(bridgePayload.userAddress, bridgePayload.nonce, bridgePayload.workflow, startingAsset);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}