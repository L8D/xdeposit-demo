{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IACLManager\n * @author Aave\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager {\n  /**\n   * @notice Returns the contract address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the identifier of the PoolAdmin role\n   * @return The id of the PoolAdmin role\n   */\n  function POOL_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the EmergencyAdmin role\n   * @return The id of the EmergencyAdmin role\n   */\n  function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the RiskAdmin role\n   * @return The id of the RiskAdmin role\n   */\n  function RISK_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the FlashBorrower role\n   * @return The id of the FlashBorrower role\n   */\n  function FLASH_BORROWER_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bridge role\n   * @return The id of the Bridge role\n   */\n  function BRIDGE_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the AssetListingAdmin role\n   * @return The id of the AssetListingAdmin role\n   */\n  function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Set the role as admin of a specific role.\n   * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n   * @param role The role to be managed by the admin role\n   * @param adminRole The admin role\n   */\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  /**\n   * @notice Adds a new admin as PoolAdmin\n   * @param admin The address of the new admin\n   */\n  function addPoolAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as PoolAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removePoolAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is PoolAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is PoolAdmin, false otherwise\n   */\n  function isPoolAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as EmergencyAdmin\n   * @param admin The address of the new admin\n   */\n  function addEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as EmergencyAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is EmergencyAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is EmergencyAdmin, false otherwise\n   */\n  function isEmergencyAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as RiskAdmin\n   * @param admin The address of the new admin\n   */\n  function addRiskAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as RiskAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeRiskAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is RiskAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is RiskAdmin, false otherwise\n   */\n  function isRiskAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as FlashBorrower\n   * @param borrower The address of the new FlashBorrower\n   */\n  function addFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Removes an address as FlashBorrower\n   * @param borrower The address of the FlashBorrower to remove\n   */\n  function removeFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Returns true if the address is FlashBorrower, false otherwise\n   * @param borrower The address to check\n   * @return True if the given address is FlashBorrower, false otherwise\n   */\n  function isFlashBorrower(address borrower) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as Bridge\n   * @param bridge The address of the new Bridge\n   */\n  function addBridge(address bridge) external;\n\n  /**\n   * @notice Removes an address as Bridge\n   * @param bridge The address of the bridge to remove\n   */\n  function removeBridge(address bridge) external;\n\n  /**\n   * @notice Returns true if the address is Bridge, false otherwise\n   * @param bridge The address to check\n   * @return True if the given address is Bridge, false otherwise\n   */\n  function isBridge(address bridge) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as AssetListingAdmin\n   * @param admin The address of the new admin\n   */\n  function addAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as AssetListingAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is AssetListingAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is AssetListingAdmin, false otherwise\n   */\n  function isAssetListingAdmin(address admin) external view returns (bool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title ICreditDelegationToken\n * @author Aave\n * @notice Defines the basic interface for a token supporting credit delegation.\n */\ninterface ICreditDelegationToken {\n  /**\n   * @dev Emitted on `approveDelegation` and `borrowAllowance\n   * @param fromUser The address of the delegator\n   * @param toUser The address of the delegatee\n   * @param asset The address of the delegated asset\n   * @param amount The amount being delegated\n   */\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address indexed asset,\n    uint256 amount\n  );\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token.\n   * Delegation will still respect the liquidation constraints (even if delegated, a\n   * delegatee cannot force a delegator HF to go below 1)\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The maximum amount being delegated.\n   */\n  function approveDelegation(address delegatee, uint256 amount) external;\n\n  /**\n   * @notice Returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return The current allowance of `toUser`\n   */\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token via ERC712 signature\n   * @param delegator The delegator of the credit\n   * @param delegatee The delegatee that can use the credit\n   * @param value The amount to be delegated\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v The V signature param\n   * @param s The S signature param\n   * @param r The R signature param\n   */\n  function delegationWithSig(\n    address delegator,\n    address delegatee,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableDebtToken\n * @author Aave\n * @notice Interface for the initialize function common between debt tokens\n */\ninterface IInitializableDebtToken {\n  /**\n   * @dev Emitted when a debt token is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param debtTokenDecimals The decimals of the debt token\n   * @param debtTokenName The name of the debt token\n   * @param debtTokenSymbol The symbol of the debt token\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address incentivesController,\n    uint8 debtTokenDecimals,\n    string debtTokenName,\n    string debtTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the debt token.\n   * @param pool The pool contract that is initializing this contract\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n   * @param debtTokenName The name of the token\n   * @param debtTokenSymbol The symbol of the token\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPriceOracleSentinel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPriceOracleSentinel\n * @author Aave\n * @notice Defines the basic interface for the PriceOracleSentinel\n */\ninterface IPriceOracleSentinel {\n  /**\n   * @dev Emitted after the sequencer oracle is updated\n   * @param newSequencerOracle The new sequencer oracle\n   */\n  event SequencerOracleUpdated(address newSequencerOracle);\n\n  /**\n   * @dev Emitted after the grace period is updated\n   * @param newGracePeriod The new grace period value\n   */\n  event GracePeriodUpdated(uint256 newGracePeriod);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns true if the `borrow` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `borrow` operation is allowed, false otherwise.\n   */\n  function isBorrowAllowed() external view returns (bool);\n\n  /**\n   * @notice Returns true if the `liquidation` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `liquidation` operation is allowed, false otherwise.\n   */\n  function isLiquidationAllowed() external view returns (bool);\n\n  /**\n   * @notice Updates the address of the sequencer oracle\n   * @param newSequencerOracle The address of the new Sequencer Oracle to use\n   */\n  function setSequencerOracle(address newSequencerOracle) external;\n\n  /**\n   * @notice Updates the duration of the grace period\n   * @param newGracePeriod The value of the new grace period duration\n   */\n  function setGracePeriod(uint256 newGracePeriod) external;\n\n  /**\n   * @notice Returns the SequencerOracle\n   * @return The address of the sequencer oracle contract\n   */\n  function getSequencerOracle() external view returns (address);\n\n  /**\n   * @notice Returns the grace period\n   * @return The duration of the grace period\n   */\n  function getGracePeriod() external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\n\n/**\n * @title IStableDebtToken\n * @author Aave\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n */\ninterface IStableDebtToken is IInitializableDebtToken {\n  /**\n   * @dev Emitted when new stable debt is minted\n   * @param user The address of the user who triggered the minting\n   * @param onBehalfOf The recipient of stable debt tokens\n   * @param amount The amount minted (user entered amount + balance increase from interest)\n   * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n   * @param balanceIncrease The increase in balance since the last action of the user 'onBehalfOf'\n   * @param newRate The rate of the debt after the minting\n   * @param avgStableRate The next average stable rate after the minting\n   * @param newTotalSupply The next total supply of the stable debt token after the action\n   */\n  event Mint(\n    address indexed user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 newRate,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Emitted when new stable debt is burned\n   * @param from The address from which the debt will be burned\n   * @param amount The amount being burned (user entered amount - balance increase from interest)\n   * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n   * @param balanceIncrease The increase in balance since the last action of 'from'\n   * @param avgStableRate The next average stable rate after the burning\n   * @param newTotalSupply The next total supply of the stable debt token after the action\n   */\n  event Burn(\n    address indexed from,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @notice Mints debt token to the `onBehalfOf` address.\n   * @dev The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   * @return True if it is the first borrow, false otherwise\n   * @return The total stable debt\n   * @return The average stable borrow rate\n   */\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 rate\n  )\n    external\n    returns (\n      bool,\n      uint256,\n      uint256\n    );\n\n  /**\n   * @notice Burns debt of `user`\n   * @dev The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest the user earned\n   * @param from The address from which the debt will be burned\n   * @param amount The amount of debt tokens getting burned\n   * @return The total stable debt\n   * @return The average stable borrow rate\n   */\n  function burn(address from, uint256 amount) external returns (uint256, uint256);\n\n  /**\n   * @notice Returns the average rate of all the stable rate loans.\n   * @return The average stable rate\n   */\n  function getAverageStableRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate of the user debt\n   * @param user The address of the user\n   * @return The stable rate of the user\n   */\n  function getUserStableRate(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the timestamp of the last update of the user\n   * @param user The address of the user\n   * @return The timestamp\n   */\n  function getUserLastUpdated(address user) external view returns (uint40);\n\n  /**\n   * @notice Returns the principal, the total supply, the average stable rate and the timestamp for the last update\n   * @return The principal\n   * @return The total supply\n   * @return The average stable rate\n   * @return The timestamp of the last update\n   */\n  function getSupplyData()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint40\n    );\n\n  /**\n   * @notice Returns the timestamp of the last update of the total supply\n   * @return The timestamp\n   */\n  function getTotalSupplyLastUpdated() external view returns (uint40);\n\n  /**\n   * @notice Returns the total supply and the average stable rate\n   * @return The total supply\n   * @return The average rate\n   */\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the principal debt balance of the user\n   * @return The debt balance of the user since the last burn/mint action\n   */\n  function principalBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of this stableDebtToken (E.g. WETH for stableDebtWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n */\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n  /**\n   * @notice Mints debt token to the `onBehalfOf` address\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt being minted\n   * @param index The variable debt index of the reserve\n   * @return True if the previous balance of the user is 0, false otherwise\n   * @return The scaled total debt of the reserve\n   */\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool, uint256);\n\n  /**\n   * @notice Burns user variable debt\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the debt will be burned\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   * @return The scaled total debt of the reserve\n   */\n  function burn(\n    address from,\n    uint256 amount,\n    uint256 index\n  ) external returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of this debtToken (E.g. WETH for variableDebtWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE = '62'; // 'User is in isolation mode'\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {WadRayMath} from './WadRayMath.sol';\n\n/**\n * @title MathUtils library\n * @author Aave\n * @notice Provides functions to perform linear and compounded interest calculations\n */\nlibrary MathUtils {\n  using WadRayMath for uint256;\n\n  /// @dev Ignoring leap years\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    //solium-disable-next-line\n    uint256 result = rate * (block.timestamp - uint256(lastUpdateTimestamp));\n    unchecked {\n      result = result / SECONDS_PER_YEAR;\n    }\n\n    return WadRayMath.RAY + result;\n  }\n\n  /**\n   * @dev Function to calculate the interest using a compounded interest rate formula\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n   *\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n   *\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great\n   * gas cost reductions. The whitepaper contains reference to the approximation and a table showing the margin of\n   * error per different time periods\n   *\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate compounded during the timeDelta, in ray\n   */\n  function calculateCompoundedInterest(\n    uint256 rate,\n    uint40 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    if (exp == 0) {\n      return WadRayMath.RAY;\n    }\n\n    uint256 expMinusOne;\n    uint256 expMinusTwo;\n    uint256 basePowerTwo;\n    uint256 basePowerThree;\n    unchecked {\n      expMinusOne = exp - 1;\n\n      expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n      basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n      basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR;\n    }\n\n    uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n    unchecked {\n      secondTerm /= 2;\n    }\n    uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n    unchecked {\n      thirdTerm /= 6;\n    }\n\n    return WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n  }\n\n  /**\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n   * @param rate The interest rate (in ray)\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n   * @return The interest rate compounded between lastUpdateTimestamp and current block timestamp, in ray\n   */\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant HALF_WAD = 0.5e18;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant HALF_RAY = 0.5e27;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a*b, in wad\n   */\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_WAD), WAD)\n    }\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a/b, in wad\n   */\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, WAD), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @notice Multiplies two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raymul b\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @notice Divides two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raydiv b\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @return b = a converted to wad, rounded half up to the nearest wad\n   */\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\n    assembly {\n      b := div(a, WAD_RAY_RATIO)\n      let remainder := mod(a, WAD_RAY_RATIO)\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n        b := add(b, 1)\n      }\n    }\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @return b = a converted in ray\n   */\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/WAD_RAY_RATIO == a\n    assembly {\n      b := mul(a, WAD_RAY_RATIO)\n\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n        revert(0, 0)\n      }\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./model/Asset.sol\";\nimport \"./model/AssetAmount.sol\";\nimport \"./model/WorkflowStepResult.sol\";\n\n/// @title The interface between WorkflowRunner and each Step implementation.abi\n/// @author Marty Saxton\n/// @notice All steps must implement this interface.\ninterface IWorkflowStep {\n    /// @notice called by WorkflowRunner to execute a workflow step.\n    /// @param assetAmounts AssetAmounts to be used by the step\n    /// @param argData Step specific arguments in ABI encoding\n    /// @return the outcome of the step invocation\n    function execute(AssetAmount[] calldata assetAmounts, bytes calldata argData)\n        external\n        payable\n        returns (WorkflowStepResult memory);\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStepAfterAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @title The interface between WorkflowRunner and each Step implementation when the step needs\n/// to do something after the steps in the workflow are done executing.\n/// @author Marty Saxton\n/// @notice This interface is optional.\ninterface IWorkflowStepAfterAll {\n  /// @notice called by WorkflowRunner to execute some logic after the workflow ends.\n  /// @param argData Step specific arguments in ABI encoding\n  function afterAll(bytes calldata argData) external payable;\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStepBeforeAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @title The interface between WorkflowRunner and each Step implementation when the step needs\n/// to do something before the steps in the workflow execute.\n/// @author Marty Saxton\n/// @notice This interface is optional.\ninterface IWorkflowStepBeforeAll {\n  /// @notice called by WorkflowRunner to execute some logic before the workflow starts.\n  /// @param argData Step specific arguments in ABI encoding\n  function beforeAll(bytes calldata argData) external payable;\n}\n"
    },
    "@freemarket/core/contracts/LibPercent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary LibPercent {\n    /// Percents have 3 decimals of precision, so:\n    /// 100% is represented as 100000 (100.000%)\n    /// 1% is represented as 1000 (1.000%)\n    /// 1 basis point (1/100th of a percent or 0.010% ) is 10\n    /// the smallest possible percentage is 1/10th of a basis point, or 1 'decibip'\n    /// @param value the value to take a percentage of\n    /// @param percent the percentage in decibips\n    function percentageOf(uint256 value, uint256 percent) internal pure returns (uint256) {\n        require(0 <= percent && percent <= 100000, \"percent must be between 0 and 100000\");\n        uint256 x = value * percent;\n        return x / 100000;\n    }\n}\n"
    },
    "@freemarket/core/contracts/model/Asset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./AssetType.sol\";\n\nstruct Asset {\n    AssetType assetType;\n    address assetAddress; // 0x0 for ETH, the ERC20 address.  If it's an account balance, this could represent the token of the account\n}\n"
    },
    "@freemarket/core/contracts/model/AssetAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\nstruct AssetAmount {\n  Asset asset;\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/AssetType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum AssetType {\n    Native,\n    ERC20,\n    ERC721\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepInputAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\n// an input asset to a WorkflowStep\nstruct WorkflowStepInputAsset {\n  // if true, the source of the asset is the caller of the workflow, otherwise it is the output of some previous step\n  bool sourceIsCaller;\n  // if true 'amount' is treated as a percent, with 4 decimals of precision (1000000 represents 100%)\n  bool amountIsPercent;\n  // the input asset\n  Asset asset;\n  // the amount of the input asset\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetAmount.sol';\n\n// The return value from the execution of a step.\nstruct WorkflowStepResult {\n  // The amounts of each input asset that resulted from the step execution.\n  AssetAmount[] inputAssetAmounts;\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmounts;\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmountsToCaller;\n  // The index of the next step in a workflow.\n  // This value allows the step to override the default nextStepIndex\n  // statically defined\n  // -1 means terminate the workflow\n  // -2 means do not override the statically defined nextStepIndex in WorkflowStep\n  int16 nextStepIndex;\n  // the fee to be withheald out of the output assets (in absolute currency units)\n  // -1 means use the default fee\n  int24 fee;\n}\n"
    },
    "@freemarket/step-sdk/contracts/ABDKMathQuad.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math Quad Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.13;\n\n/**\n * Smart contract library of mathematical functions operating with IEEE 754\n * quadruple-precision binary floating-point numbers (quadruple precision\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n * represented by bytes16 type.\n */\nlibrary ABDKMathQuad {\n    /*\n    * 0.\n    */\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n\n    /*\n    * -0.\n    */\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n\n    /*\n    * +Infinity.\n    */\n    bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n\n    /*\n    * -Infinity.\n    */\n    bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n\n    /*\n    * Canonical NaN value.\n    */\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n\n    /**\n     * Convert signed 256-bit integer number into quadruple precision number.\n     *\n     * @param x signed 256-bit integer number\n     * @return quadruple precision number\n     */\n    function fromInt(int256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) {\n                return bytes16(0);\n            } else {\n                // We rely on overflow behavior here\n                uint256 result = uint256(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 256-bit integer number\n     * rounding towards zero.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 256-bit integer number\n     */\n    function toInt(bytes16 x) internal pure returns (int256) {\n        unchecked {\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n\n            require(exponent <= 16638); // Overflow\n            if (exponent < 16383) return 0; // Underflow\n\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\n\n            if (exponent < 16495) result >>= 16495 - exponent;\n            else if (exponent > 16495) result <<= exponent - 16495;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n                return -int256(result); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n                return int256(result);\n            }\n        }\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into quadruple precision number.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return quadruple precision number\n     */\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) {\n                return bytes16(0);\n            } else {\n                uint256 result = x;\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into unsigned 256-bit integer number\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n     * without error, because they are rounded to zero.\n     *\n     * @param x quadruple precision number\n     * @return unsigned 256-bit integer number\n     */\n    function toUInt(bytes16 x) internal pure returns (uint256) {\n        unchecked {\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n\n            if (exponent < 16383) return 0; // Underflow\n\n            require(uint128(x) < 0x80000000000000000000000000000000); // Negative\n\n            require(exponent <= 16638); // Overflow\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\n\n            if (exponent < 16495) result >>= 16495 - exponent;\n            else if (exponent > 16495) result <<= exponent - 16495;\n\n            return result;\n        }\n    }\n\n    /**\n     * Convert signed 128.128 bit fixed point number into quadruple precision\n     * number.\n     *\n     * @param x signed 128.128 bit fixed point number\n     * @return quadruple precision number\n     */\n    function from128x128(int256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) {\n                return bytes16(0);\n            } else {\n                // We rely on overflow behavior here\n                uint256 result = uint256(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 128.128 bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 128.128 bit fixed point number\n     */\n    function to128x128(bytes16 x) internal pure returns (int256) {\n        unchecked {\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n\n            require(exponent <= 16510); // Overflow\n            if (exponent < 16255) return 0; // Underflow\n\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\n\n            if (exponent < 16367) result >>= 16367 - exponent;\n            else if (exponent > 16367) result <<= exponent - 16367;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n                return -int256(result); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n                return int256(result);\n            }\n        }\n    }\n\n    /**\n     * Convert signed 64.64 bit fixed point number into quadruple precision\n     * number.\n     *\n     * @param x signed 64.64 bit fixed point number\n     * @return quadruple precision number\n     */\n    function from64x64(int128 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) {\n                return bytes16(0);\n            } else {\n                // We rely on overflow behavior here\n                uint256 result = uint128(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 64.64 bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 64.64 bit fixed point number\n     */\n    function to64x64(bytes16 x) internal pure returns (int128) {\n        unchecked {\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n\n            require(exponent <= 16446); // Overflow\n            if (exponent < 16319) return 0; // Underflow\n\n            uint256 result = uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000;\n\n            if (exponent < 16431) result >>= 16431 - exponent;\n            else if (exponent > 16431) result <<= exponent - 16431;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x80000000000000000000000000000000);\n                return -int128(int256(result)); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n                return int128(int256(result));\n            }\n        }\n    }\n\n    /**\n     * Convert octuple precision number into quadruple precision number.\n     *\n     * @param x octuple precision number\n     * @return quadruple precision number\n     */\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\n        unchecked {\n            bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\n\n            uint256 exponent = uint256(x) >> 236 & 0x7FFFF;\n            uint256 significand = uint256(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFFF) {\n                if (significand > 0) return NaN;\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            }\n\n            if (exponent > 278526) {\n                return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            } else if (exponent < 245649) {\n                return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n            } else if (exponent < 245761) {\n                significand =\n                    (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\n                exponent = 0;\n            } else {\n                significand >>= 124;\n                exponent -= 245760;\n            }\n\n            uint128 result = uint128(significand | exponent << 112);\n            if (negative) result |= 0x80000000000000000000000000000000;\n\n            return bytes16(result);\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into octuple precision number.\n     *\n     * @param x quadruple precision number\n     * @return octuple precision number\n     */\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\n        unchecked {\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFF) {\n                exponent = 0x7FFFF;\n            } // Infinity or NaN\n            else if (exponent == 0) {\n                if (result > 0) {\n                    uint256 msb = mostSignificantBit(result);\n                    result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    exponent = 245649 + msb;\n                }\n            } else {\n                result <<= 124;\n                exponent += 245760;\n            }\n\n            result |= exponent << 236;\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n            }\n\n            return bytes32(result);\n        }\n    }\n\n    /**\n     * Convert double precision number into quadruple precision number.\n     *\n     * @param x double precision number\n     * @return quadruple precision number\n     */\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\n        unchecked {\n            uint256 exponent = uint64(x) >> 52 & 0x7FF;\n\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FF) {\n                exponent = 0x7FFF;\n            } // Infinity or NaN\n            else if (exponent == 0) {\n                if (result > 0) {\n                    uint256 msb = mostSignificantBit(result);\n                    result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    exponent = 15309 + msb;\n                }\n            } else {\n                result <<= 60;\n                exponent += 15360;\n            }\n\n            result |= exponent << 112;\n            if (x & 0x8000000000000000 > 0) {\n                result |= 0x80000000000000000000000000000000;\n            }\n\n            return bytes16(uint128(result));\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into double precision number.\n     *\n     * @param x quadruple precision number\n     * @return double precision number\n     */\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\n        unchecked {\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\n\n            uint256 exponent = uint128(x) >> 112 & 0x7FFF;\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFF) {\n                if (significand > 0) {\n                    return 0x7FF8000000000000;\n                } // NaN\n                else {\n                    return negative\n                        ? bytes8(0xFFF0000000000000) // -Infinity\n                        : bytes8(0x7FF0000000000000);\n                } // Infinity\n            }\n\n            if (exponent > 17406) {\n                return negative\n                    ? bytes8(0xFFF0000000000000) // -Infinity\n                    : bytes8(0x7FF0000000000000);\n            } // Infinity\n            else if (exponent < 15309) {\n                return negative\n                    ? bytes8(0x8000000000000000) // -0\n                    : bytes8(0x0000000000000000);\n            } // 0\n            else if (exponent < 15361) {\n                significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\n                exponent = 0;\n            } else {\n                significand >>= 60;\n                exponent -= 15360;\n            }\n\n            uint64 result = uint64(significand | exponent << 52);\n            if (negative) result |= 0x8000000000000000;\n\n            return bytes8(result);\n        }\n    }\n\n    /**\n     * Test whether given quadruple precision number is NaN.\n     *\n     * @param x quadruple precision number\n     * @return true if x is NaN, false otherwise\n     */\n    function isNaN(bytes16 x) internal pure returns (bool) {\n        unchecked {\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 0x7FFF0000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Test whether given quadruple precision number is positive or negative\n     * infinity.\n     *\n     * @param x quadruple precision number\n     * @return true if x is positive or negative infinity, false otherwise\n     */\n    function isInfinity(bytes16 x) internal pure returns (bool) {\n        unchecked {\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0x7FFF0000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\n     *\n     * @param x quadruple precision number\n     * @return sign of x\n     */\n    function sign(bytes16 x) internal pure returns (int8) {\n        unchecked {\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n            if (absoluteX == 0) return 0;\n            else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\n            else return 1;\n        }\n    }\n\n    /**\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\n     * arguments are infinities of the same sign.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return sign (x - y)\n     */\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\n        unchecked {\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n            // Not infinities of the same sign\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\n\n            if (x == y) {\n                return 0;\n            } else {\n                bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\n                bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\n\n                if (negativeX) {\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\n                    else return -1;\n                } else {\n                    if (negativeY) return 1;\n                    else return absoluteX > absoluteY ? int8(1) : -1;\n                }\n            }\n        }\n    }\n\n    /**\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n     * anything.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return true if x equals to y, false otherwise\n     */\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\n        unchecked {\n            if (x == y) {\n                return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 0x7FFF0000000000000000000000000000;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Calculate x + y.  Special values behave in the following way:\n     *\n     * NaN + x = NaN for any x.\n     * Infinity + x = Infinity for any finite x.\n     * -Infinity + x = -Infinity for any finite x.\n     * Infinity + Infinity = Infinity.\n     * -Infinity + -Infinity = -Infinity.\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) {\n                    if (x == y) return x;\n                    else return NaN;\n                } else {\n                    return x;\n                }\n            } else if (yExponent == 0x7FFF) {\n                return y;\n            } else {\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                if (xSignifier == 0) {\n                    return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n                } else if (ySignifier == 0) {\n                    return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n                } else {\n                    int256 delta = int256(xExponent) - int256(yExponent);\n\n                    if (xSign == ySign) {\n                        if (delta > 112) {\n                            return x;\n                        } else if (delta > 0) {\n                            ySignifier >>= uint256(delta);\n                        } else if (delta < -112) {\n                            return y;\n                        } else if (delta < 0) {\n                            xSignifier >>= uint256(-delta);\n                            xExponent = yExponent;\n                        }\n\n                        xSignifier += ySignifier;\n\n                        if (xSignifier >= 0x20000000000000000000000000000) {\n                            xSignifier >>= 1;\n                            xExponent += 1;\n                        }\n\n                        if (xExponent == 0x7FFF) {\n                            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n                        } else {\n                            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                            return bytes16(\n                                uint128(\n                                    (xSign ? 0x80000000000000000000000000000000 : 0) | (xExponent << 112) | xSignifier\n                                )\n                            );\n                        }\n                    } else {\n                        if (delta > 0) {\n                            xSignifier <<= 1;\n                            xExponent -= 1;\n                        } else if (delta < 0) {\n                            ySignifier <<= 1;\n                            xExponent = yExponent - 1;\n                        }\n\n                        if (delta > 112) ySignifier = 1;\n                        else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256(delta - 1)) + 1;\n                        else if (delta < -112) xSignifier = 1;\n                        else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256(-delta - 1)) + 1;\n\n                        if (xSignifier >= ySignifier) {\n                            xSignifier -= ySignifier;\n                        } else {\n                            xSignifier = ySignifier - xSignifier;\n                            xSign = ySign;\n                        }\n\n                        if (xSignifier == 0) {\n                            return POSITIVE_ZERO;\n                        }\n\n                        uint256 msb = mostSignificantBit(xSignifier);\n\n                        if (msb == 113) {\n                            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                            xExponent += 1;\n                        } else if (msb < 112) {\n                            uint256 shift = 112 - msb;\n                            if (xExponent > shift) {\n                                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                                xExponent -= shift;\n                            } else {\n                                xSignifier <<= xExponent - 1;\n                                xExponent = 0;\n                            }\n                        } else {\n                            xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                        }\n\n                        if (xExponent == 0x7FFF) {\n                            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n                        } else {\n                            return bytes16(\n                                uint128(\n                                    (xSign ? 0x80000000000000000000000000000000 : 0) | (xExponent << 112) | xSignifier\n                                )\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate x - y.  Special values behave in the following way:\n     *\n     * NaN - x = NaN for any x.\n     * Infinity - x = Infinity for any finite x.\n     * -Infinity - x = -Infinity for any finite x.\n     * Infinity - -Infinity = Infinity.\n     * -Infinity - Infinity = -Infinity.\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            return add(x, y ^ 0x80000000000000000000000000000000);\n        }\n    }\n\n    /**\n     * Calculate x * y.  Special values behave in the following way:\n     *\n     * NaN * x = NaN for any x.\n     * Infinity * x = Infinity for any finite positive x.\n     * Infinity * x = -Infinity for any finite negative x.\n     * -Infinity * x = -Infinity for any finite positive x.\n     * -Infinity * x = Infinity for any finite negative x.\n     * Infinity * 0 = NaN.\n     * -Infinity * 0 = NaN.\n     * Infinity * Infinity = Infinity.\n     * Infinity * -Infinity = -Infinity.\n     * -Infinity * Infinity = -Infinity.\n     * -Infinity * -Infinity = Infinity.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) {\n                    if (x == y) return x ^ y & 0x80000000000000000000000000000000;\n                    else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n                    else return NaN;\n                } else {\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                    else return x ^ y & 0x80000000000000000000000000000000;\n                }\n            } else if (yExponent == 0x7FFF) {\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                else return y ^ x & 0x80000000000000000000000000000000;\n            } else {\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                xSignifier *= ySignifier;\n                if (xSignifier == 0) {\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\n                }\n\n                xExponent += yExponent;\n\n                uint256 msb = xSignifier >= 0x200000000000000000000000000000000000000000000000000000000\n                    ? 225\n                    : xSignifier >= 0x100000000000000000000000000000000000000000000000000000000\n                        ? 224\n                        : mostSignificantBit(xSignifier);\n\n                if (xExponent + msb < 16496) {\n                    // Underflow\n                    xExponent = 0;\n                    xSignifier = 0;\n                } else if (xExponent + msb < 16608) {\n                    // Subnormal\n                    if (xExponent < 16496) {\n                        xSignifier >>= 16496 - xExponent;\n                    } else if (xExponent > 16496) {\n                        xSignifier <<= xExponent - 16496;\n                    }\n                    xExponent = 0;\n                } else if (xExponent + msb > 49373) {\n                    xExponent = 0x7FFF;\n                    xSignifier = 0;\n                } else {\n                    if (msb > 112) {\n                        xSignifier >>= msb - 112;\n                    } else if (msb < 112) {\n                        xSignifier <<= 112 - msb;\n                    }\n\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                    xExponent = xExponent + msb - 16607;\n                }\n\n                return bytes16(\n                    uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | xExponent << 112 | xSignifier)\n                );\n            }\n        }\n    }\n\n    /**\n     * Calculate x / y.  Special values behave in the following way:\n     *\n     * NaN / x = NaN for any x.\n     * x / NaN = NaN for any x.\n     * Infinity / x = Infinity for any finite non-negative x.\n     * Infinity / x = -Infinity for any finite negative x including -0.\n     * -Infinity / x = -Infinity for any finite non-negative x.\n     * -Infinity / x = Infinity for any finite negative x including -0.\n     * x / Infinity = 0 for any finite non-negative x.\n     * x / -Infinity = -0 for any finite non-negative x.\n     * x / Infinity = -0 for any finite non-negative x including -0.\n     * x / -Infinity = 0 for any finite non-negative x including -0.\n     *\n     * Infinity / Infinity = NaN.\n     * Infinity / -Infinity = -NaN.\n     * -Infinity / Infinity = -NaN.\n     * -Infinity / -Infinity = NaN.\n     *\n     * Division by zero behaves in the following way:\n     *\n     * x / 0 = Infinity for any finite positive x.\n     * x / -0 = -Infinity for any finite positive x.\n     * x / 0 = -Infinity for any finite negative x.\n     * x / -0 = Infinity for any finite negative x.\n     * 0 / 0 = NaN.\n     * 0 / -0 = NaN.\n     * -0 / 0 = NaN.\n     * -0 / -0 = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n            uint256 yExponent = uint128(y) >> 112 & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) return NaN;\n                else return x ^ y & 0x80000000000000000000000000000000;\n            } else if (yExponent == 0x7FFF) {\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n                else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\n            } else {\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) {\n                    if (xSignifier != 0) {\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\n\n                        xSignifier <<= shift;\n\n                        xExponent = 1;\n                        yExponent += shift - 114;\n                    }\n                } else {\n                    xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n                }\n\n                xSignifier = xSignifier / ySignifier;\n                if (xSignifier == 0) {\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\n                }\n\n                assert(xSignifier >= 0x1000000000000000000000000000);\n\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\n                    ? mostSignificantBit(xSignifier)\n                    : xSignifier >= 0x40000000000000000000000000000\n                        ? 114\n                        : xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\n\n                if (xExponent + msb > yExponent + 16497) {\n                    // Overflow\n                    xExponent = 0x7FFF;\n                    xSignifier = 0;\n                } else if (xExponent + msb + 16380 < yExponent) {\n                    // Underflow\n                    xExponent = 0;\n                    xSignifier = 0;\n                } else if (xExponent + msb + 16268 < yExponent) {\n                    // Subnormal\n                    if (xExponent + 16380 > yExponent) {\n                        xSignifier <<= xExponent + 16380 - yExponent;\n                    } else if (xExponent + 16380 < yExponent) {\n                        xSignifier >>= yExponent - xExponent - 16380;\n                    }\n\n                    xExponent = 0;\n                } else {\n                    // Normal\n                    if (msb > 112) {\n                        xSignifier >>= msb - 112;\n                    }\n\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                    xExponent = xExponent + msb + 16269 - yExponent;\n                }\n\n                return bytes16(\n                    uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | xExponent << 112 | xSignifier)\n                );\n            }\n        }\n    }\n\n    /**\n     * Calculate -x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function neg(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return x ^ 0x80000000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Calculate |x|.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function abs(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        }\n    }\n\n    /**\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            if (uint128(x) > 0x80000000000000000000000000000000) {\n                return NaN;\n            } else {\n                uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n                if (xExponent == 0x7FFF) {\n                    return x;\n                } else {\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    if (xExponent == 0) xExponent = 1;\n                    else xSignifier |= 0x10000000000000000000000000000;\n\n                    if (xSignifier == 0) return POSITIVE_ZERO;\n\n                    bool oddExponent = xExponent & 0x1 == 0;\n                    xExponent = xExponent + 16383 >> 1;\n\n                    if (oddExponent) {\n                        if (xSignifier >= 0x10000000000000000000000000000) {\n                            xSignifier <<= 113;\n                        } else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            uint256 shift = (226 - msb) & 0xFE;\n                            xSignifier <<= shift;\n                            xExponent -= shift - 112 >> 1;\n                        }\n                    } else {\n                        if (xSignifier >= 0x10000000000000000000000000000) {\n                            xSignifier <<= 112;\n                        } else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            uint256 shift = (225 - msb) & 0xFE;\n                            xSignifier <<= shift;\n                            xExponent -= shift - 112 >> 1;\n                        }\n                    }\n\n                    uint256 r = 0x10000000000000000000000000000;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n                    uint256 r1 = xSignifier / r;\n                    if (r1 < r) r = r1;\n\n                    return bytes16(uint128(xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function log_2(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            if (uint128(x) > 0x80000000000000000000000000000000) {\n                return NaN;\n            } else if (x == 0x3FFF0000000000000000000000000000) {\n                return POSITIVE_ZERO;\n            } else {\n                uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n                if (xExponent == 0x7FFF) {\n                    return x;\n                } else {\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    if (xExponent == 0) xExponent = 1;\n                    else xSignifier |= 0x10000000000000000000000000000;\n\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\n\n                    bool resultNegative;\n                    uint256 resultExponent = 16495;\n                    uint256 resultSignifier;\n\n                    if (xExponent >= 0x3FFF) {\n                        resultNegative = false;\n                        resultSignifier = xExponent - 0x3FFF;\n                        xSignifier <<= 15;\n                    } else {\n                        resultNegative = true;\n                        if (xSignifier >= 0x10000000000000000000000000000) {\n                            resultSignifier = 0x3FFE - xExponent;\n                            xSignifier <<= 15;\n                        } else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            resultSignifier = 16493 - msb;\n                            xSignifier <<= 127 - msb;\n                        }\n                    }\n\n                    if (xSignifier == 0x80000000000000000000000000000000) {\n                        if (resultNegative) resultSignifier += 1;\n                        uint256 shift = 112 - mostSignificantBit(resultSignifier);\n                        resultSignifier <<= shift;\n                        resultExponent -= shift;\n                    } else {\n                        uint256 bb = resultNegative ? 1 : 0;\n                        while (resultSignifier < 0x10000000000000000000000000000) {\n                            resultSignifier <<= 1;\n                            resultExponent -= 1;\n\n                            xSignifier *= xSignifier;\n                            uint256 b = xSignifier >> 255;\n                            resultSignifier += b ^ bb;\n                            xSignifier >>= 127 + b;\n                        }\n                    }\n\n                    return bytes16(\n                        uint128(\n                            (resultNegative ? 0x80000000000000000000000000000000 : 0) | resultExponent << 112\n                                | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                        )\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function ln(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n        }\n    }\n\n    /**\n     * Calculate 2^x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\n            uint256 xExponent = uint128(x) >> 112 & 0x7FFF;\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (xExponent == 0x7FFF && xSignifier != 0) {\n                return NaN;\n            } else if (xExponent > 16397) {\n                return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n            } else if (xExponent < 16255) {\n                return 0x3FFF0000000000000000000000000000;\n            } else {\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                if (xExponent > 16367) {\n                    xSignifier <<= xExponent - 16367;\n                } else if (xExponent < 16367) {\n                    xSignifier >>= 16367 - xExponent;\n                }\n\n                if (xNegative && xSignifier > 0x406E00000000000000000000000000000000) {\n                    return POSITIVE_ZERO;\n                }\n\n                if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                    return POSITIVE_INFINITY;\n                }\n\n                uint256 resultExponent = xSignifier >> 128;\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xNegative && xSignifier != 0) {\n                    xSignifier = ~xSignifier;\n                    resultExponent += 1;\n                }\n\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\n                if (xSignifier & 0x80000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n                }\n                if (xSignifier & 0x40000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n                }\n                if (xSignifier & 0x20000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n                }\n                if (xSignifier & 0x10000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n                }\n                if (xSignifier & 0x8000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n                }\n                if (xSignifier & 0x4000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n                }\n                if (xSignifier & 0x2000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n                }\n                if (xSignifier & 0x1000000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n                }\n                if (xSignifier & 0x800000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n                }\n                if (xSignifier & 0x400000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n                }\n                if (xSignifier & 0x200000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n                }\n                if (xSignifier & 0x100000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n                }\n                if (xSignifier & 0x80000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n                }\n                if (xSignifier & 0x40000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n                }\n                if (xSignifier & 0x20000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\n                }\n                if (xSignifier & 0x10000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n                }\n                if (xSignifier & 0x8000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n                }\n                if (xSignifier & 0x4000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n                }\n                if (xSignifier & 0x2000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n                }\n                if (xSignifier & 0x1000000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n                }\n                if (xSignifier & 0x800000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n                }\n                if (xSignifier & 0x400000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n                }\n                if (xSignifier & 0x200000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n                }\n                if (xSignifier & 0x100000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n                }\n                if (xSignifier & 0x80000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n                }\n                if (xSignifier & 0x40000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n                }\n                if (xSignifier & 0x20000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n                }\n                if (xSignifier & 0x10000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n                }\n                if (xSignifier & 0x8000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n                }\n                if (xSignifier & 0x4000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n                }\n                if (xSignifier & 0x2000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n                }\n                if (xSignifier & 0x1000000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n                }\n                if (xSignifier & 0x800000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n                }\n                if (xSignifier & 0x400000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n                }\n                if (xSignifier & 0x200000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n                }\n                if (xSignifier & 0x100000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n                }\n                if (xSignifier & 0x80000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n                }\n                if (xSignifier & 0x40000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n                }\n                if (xSignifier & 0x20000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n                }\n                if (xSignifier & 0x10000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n                }\n                if (xSignifier & 0x8000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n                }\n                if (xSignifier & 0x4000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\n                }\n                if (xSignifier & 0x2000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\n                }\n                if (xSignifier & 0x1000000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\n                }\n                if (xSignifier & 0x800000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n                }\n                if (xSignifier & 0x400000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n                }\n                if (xSignifier & 0x200000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n                }\n                if (xSignifier & 0x100000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n                }\n                if (xSignifier & 0x80000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n                }\n                if (xSignifier & 0x40000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n                }\n                if (xSignifier & 0x20000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\n                }\n                if (xSignifier & 0x10000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n                }\n                if (xSignifier & 0x8000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n                }\n                if (xSignifier & 0x4000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\n                }\n                if (xSignifier & 0x2000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n                }\n                if (xSignifier & 0x1000000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\n                }\n                if (xSignifier & 0x800000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n                }\n                if (xSignifier & 0x400000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n                }\n                if (xSignifier & 0x200000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\n                }\n                if (xSignifier & 0x100000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n                }\n                if (xSignifier & 0x80000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n                }\n                if (xSignifier & 0x40000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n                }\n                if (xSignifier & 0x20000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\n                }\n                if (xSignifier & 0x10000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\n                }\n                if (xSignifier & 0x8000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\n                }\n                if (xSignifier & 0x4000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\n                }\n                if (xSignifier & 0x2000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\n                }\n                if (xSignifier & 0x1000000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\n                }\n                if (xSignifier & 0x800000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\n                }\n                if (xSignifier & 0x400000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\n                }\n                if (xSignifier & 0x200000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\n                }\n                if (xSignifier & 0x100000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\n                }\n                if (xSignifier & 0x80000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\n                }\n                if (xSignifier & 0x40000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\n                }\n                if (xSignifier & 0x20000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\n                }\n                if (xSignifier & 0x10000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\n                }\n                if (xSignifier & 0x8000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\n                }\n                if (xSignifier & 0x4000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\n                }\n                if (xSignifier & 0x2000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\n                }\n                if (xSignifier & 0x1000000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\n                }\n                if (xSignifier & 0x800000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\n                }\n                if (xSignifier & 0x400000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\n                }\n                if (xSignifier & 0x200000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\n                }\n                if (xSignifier & 0x100000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\n                }\n                if (xSignifier & 0x80000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\n                }\n                if (xSignifier & 0x40000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\n                }\n                if (xSignifier & 0x20000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\n                }\n                if (xSignifier & 0x10000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\n                }\n                if (xSignifier & 0x8000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\n                }\n                if (xSignifier & 0x4000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\n                }\n                if (xSignifier & 0x2000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\n                }\n                if (xSignifier & 0x1000000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\n                }\n                if (xSignifier & 0x800000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\n                }\n                if (xSignifier & 0x400000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\n                }\n                if (xSignifier & 0x200000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\n                }\n                if (xSignifier & 0x100000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\n                }\n                if (xSignifier & 0x80000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\n                }\n                if (xSignifier & 0x40000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\n                }\n                if (xSignifier & 0x20000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\n                }\n                if (xSignifier & 0x10000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\n                }\n                if (xSignifier & 0x8000000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\n                }\n                if (xSignifier & 0x4000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\n                }\n                if (xSignifier & 0x2000000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\n                }\n                if (xSignifier & 0x1000000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\n                }\n                if (xSignifier & 0x800000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\n                }\n                if (xSignifier & 0x400000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\n                }\n                if (xSignifier & 0x200000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\n                }\n                if (xSignifier & 0x100000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\n                }\n                if (xSignifier & 0x80000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\n                }\n                if (xSignifier & 0x40000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\n                }\n                if (xSignifier & 0x20000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\n                }\n                if (xSignifier & 0x10000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\n                }\n                if (xSignifier & 0x8000 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\n                }\n                if (xSignifier & 0x4000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\n                }\n                if (xSignifier & 0x2000 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\n                }\n                if (xSignifier & 0x1000 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\n                }\n                if (xSignifier & 0x800 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\n                }\n                if (xSignifier & 0x400 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\n                }\n                if (xSignifier & 0x200 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\n                }\n                if (xSignifier & 0x100 > 0) {\n                    resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\n                }\n                if (xSignifier & 0x80 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\n                }\n                if (xSignifier & 0x40 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\n                }\n                if (xSignifier & 0x20 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\n                }\n                if (xSignifier & 0x10 > 0) {\n                    resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\n                }\n                if (xSignifier & 0x8 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\n                }\n                if (xSignifier & 0x4 > 0) {\n                    resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\n                }\n\n                if (!xNegative) {\n                    resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    resultExponent += 0x3FFF;\n                } else if (resultExponent <= 0x3FFE) {\n                    resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    resultExponent = 0x3FFF - resultExponent;\n                } else {\n                    resultSignifier = resultSignifier >> resultExponent - 16367;\n                    resultExponent = 0;\n                }\n\n                return bytes16(uint128(resultExponent << 112 | resultSignifier));\n            }\n        }\n    }\n\n    /**\n     * Calculate e^x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function exp(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n        }\n    }\n\n    /**\n     * Get index of the most significant non-zero bit in binary representation of\n     * x.  Reverts if x is zero.\n     *\n     * @return index of the most significant non-zero bit in binary representation\n     *         of x\n     */\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\n        unchecked {\n            require(x > 0);\n\n            uint256 result = 0;\n\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                result += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                result += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                result += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                result += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                result += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                result += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                result += 2;\n            }\n            if (x >= 0x2) result += 1; // No need to shift x anymore\n\n            return result;\n        }\n    }\n}\n"
    },
    "@freemarket/step-sdk/contracts/IWeth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IWeth {\n  function deposit() external payable;\n\n  function withdraw(uint) external;\n}\n"
    },
    "@freemarket/step-sdk/contracts/LibErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary LibErc20 {\n    using Address for address;\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // forked from openzeppelin but removed the require, just keeping optional return\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@freemarket/step-sdk/contracts/LibStepResultBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/model/AssetType.sol';\nimport '@freemarket/core/contracts/model/WorkflowStepResult.sol';\n\nstruct StepResultBuilder {\n  uint256 inputIndex;\n  uint256 outputIndex;\n  uint256 outputToCallerIndex;\n  WorkflowStepResult result;\n}\n\nlibrary LibStepResultBuilder {\n  function create(uint256 inputAssetCount, uint256 outputAssetCount) internal pure returns (StepResultBuilder memory) {\n    AssetAmount[] memory inputAssetAmounts = new AssetAmount[](inputAssetCount);\n    AssetAmount[] memory ouputAssetAmounts = new AssetAmount[](outputAssetCount);\n    AssetAmount[] memory ouputAssetAmountsToCaller = new AssetAmount[](0);\n\n    return StepResultBuilder(0, 0, 0, WorkflowStepResult(inputAssetAmounts, ouputAssetAmounts, ouputAssetAmountsToCaller, -2, -1));\n  }\n\n  function create(\n    uint256 inputAssetCount,\n    uint256 outputAssetCount,\n    uint256 outputAssetToCallerCount\n  ) internal pure returns (StepResultBuilder memory) {\n    AssetAmount[] memory inputAssetAmounts = new AssetAmount[](inputAssetCount);\n    AssetAmount[] memory ouputAssetAmounts = new AssetAmount[](outputAssetCount);\n    AssetAmount[] memory ouputAssetToCallerAmounts = new AssetAmount[](outputAssetToCallerCount);\n\n    return StepResultBuilder(0, 0, 0, WorkflowStepResult(inputAssetAmounts, ouputAssetAmounts, ouputAssetToCallerAmounts, -2, -1));\n  }\n\n  function addInputToken(\n    StepResultBuilder memory builder,\n    address tokenAddress,\n    uint256 amount\n  ) internal pure returns (StepResultBuilder memory) {\n    builder.result.inputAssetAmounts[builder.inputIndex++] = AssetAmount(Asset(AssetType.ERC20, tokenAddress), amount);\n    return builder;\n  }\n\n  function addInputAssetAmount(\n    StepResultBuilder memory builder,\n    AssetAmount memory assetAmount\n  ) internal pure returns (StepResultBuilder memory) {\n    builder.result.inputAssetAmounts[builder.inputIndex++] = assetAmount;\n    return builder;\n  }\n\n  function addOutputToken(\n    StepResultBuilder memory builder,\n    address tokenAddress,\n    uint256 amount\n  ) internal pure returns (StepResultBuilder memory) {\n    builder.result.outputAssetAmounts[builder.outputIndex++] = AssetAmount(Asset(AssetType.ERC20, tokenAddress), amount);\n    return builder;\n  }\n\n  function addInputNative(StepResultBuilder memory builder, uint256 amount) internal pure returns (StepResultBuilder memory) {\n    builder.result.inputAssetAmounts[builder.inputIndex++] = AssetAmount(Asset(AssetType.Native, address(0)), amount);\n    return builder;\n  }\n\n  function addOutputNative(StepResultBuilder memory builder, uint256 amount) internal pure returns (StepResultBuilder memory) {\n    builder.result.outputAssetAmounts[builder.outputIndex++] = AssetAmount(Asset(AssetType.Native, address(0)), amount);\n    return builder;\n  }\n\n  function addOutputAssetAmount(\n    StepResultBuilder memory builder,\n    AssetAmount memory assetAmount\n  ) internal pure returns (StepResultBuilder memory) {\n    builder.result.outputAssetAmounts[builder.outputIndex++] = assetAmount;\n    return builder;\n  }\n\n  function addOutputAssetAmountToCaller(\n    StepResultBuilder memory builder,\n    AssetAmount memory assetAmount\n  ) internal pure returns (StepResultBuilder memory) {\n    builder.result.outputAssetAmountsToCaller[builder.outputToCallerIndex++] = assetAmount;\n    return builder;\n  }\n\n  function setNextStepIndex(StepResultBuilder memory builder, int16 nextStepIndex) internal pure returns (StepResultBuilder memory) {\n    builder.result.nextStepIndex = nextStepIndex;\n    return builder;\n  }\n\n  function setFee(StepResultBuilder memory builder, int24 feeInDeciBips) internal pure returns (StepResultBuilder memory) {\n    builder.result.fee = feeInDeciBips;\n    return builder;\n  }\n}\n"
    },
    "@freemarket/step-sdk/contracts/LibWethUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport '@freemarket/core/contracts/model/AssetAmount.sol';\nimport './IWeth.sol';\n\nlibrary LibWethUtils {\n  function wrapIfNecessary(AssetAmount memory assetAmount, address wethAddress) internal returns (address) {\n    if (assetAmount.asset.assetType == AssetType.Native) {\n      require(wethAddress != address(0), 'weth not supported on this chain');\n      IWeth(wethAddress).deposit{value: assetAmount.amount}();\n      return wethAddress;\n    }\n    return assetAmount.asset.assetAddress;\n  }\n}\n"
    },
    "@freemarket/step-sdk/contracts/TestErc20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/// An ERC20 contract with external mint and burn, useful for testing.\ncontract TestErc20 is ERC20 {\n  uint8 public immutable _decimals;\n\n  constructor(string memory _symbol, uint8 dec) ERC20(_symbol, _symbol) {\n    _decimals = dec;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return _decimals;\n  }\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external {\n    _burn(account, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/aave-interfaces/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "contracts/aave-interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "contracts/aave-interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode);\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode);\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens);\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(address indexed reserve, address indexed user, DataTypes.InterestRateMode interestRateMode);\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 referralCode) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "contracts/aave-interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/aave-interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/aave-interfaces/IPriceOracleSentinel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPriceOracleSentinel\n * @author Aave\n * @notice Defines the basic interface for the PriceOracleSentinel\n */\ninterface IPriceOracleSentinel {\n  /**\n   * @dev Emitted after the sequencer oracle is updated\n   * @param newSequencerOracle The new sequencer oracle\n   */\n  event SequencerOracleUpdated(address newSequencerOracle);\n\n  /**\n   * @dev Emitted after the grace period is updated\n   * @param newGracePeriod The new grace period value\n   */\n  event GracePeriodUpdated(uint256 newGracePeriod);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns true if the `borrow` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `borrow` operation is allowed, false otherwise.\n   */\n  function isBorrowAllowed() external view returns (bool);\n\n  /**\n   * @notice Returns true if the `liquidation` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `liquidation` operation is allowed, false otherwise.\n   */\n  function isLiquidationAllowed() external view returns (bool);\n\n  /**\n   * @notice Updates the address of the sequencer oracle\n   * @param newSequencerOracle The address of the new Sequencer Oracle to use\n   */\n  function setSequencerOracle(address newSequencerOracle) external;\n\n  /**\n   * @notice Updates the duration of the grace period\n   * @param newGracePeriod The value of the new grace period duration\n   */\n  function setGracePeriod(uint256 newGracePeriod) external;\n\n  /**\n   * @notice Returns the SequencerOracle\n   * @return The address of the sequencer oracle contract\n   */\n  function getSequencerOracle() external view returns (address);\n\n  /**\n   * @notice Returns the grace period\n   * @return The duration of the grace period\n   */\n  function getGracePeriod() external view returns (uint256);\n}\n"
    },
    "contracts/AaveBorrowAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/IWorkflowStep.sol';\nimport '@freemarket/core/contracts/IWorkflowStepBeforeAll.sol';\nimport '@freemarket/core/contracts/IWorkflowStepAfterAll.sol';\nimport '@freemarket/core/contracts/model/AssetAmount.sol';\nimport '@freemarket/core/contracts/LibPercent.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@freemarket/step-sdk/contracts/LibStepResultBuilder.sol';\nimport '@freemarket/step-sdk/contracts/LibErc20.sol';\nimport '@freemarket/step-sdk/contracts/LibWethUtils.sol';\nimport '@freemarket/step-sdk/contracts/ABDKMathQuad.sol';\nimport '@freemarket/step-sdk/contracts/IWeth.sol';\n\nimport '@freemarket/core/contracts/model/WorkflowStepInputAsset.sol';\nimport '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport '@aave/core-v3/contracts/interfaces/IPriceOracleSentinel.sol';\nimport '@aave/core-v3/contracts/interfaces/IAaveOracle.sol';\nimport '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport '@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol';\n\nusing LibStepResultBuilder for StepResultBuilder;\nusing LibErc20 for IERC20;\nusing ABDKMathQuad for bytes16;\n\nstruct DelegationWithSignatureArgs {\n  uint256 amount;\n  uint256 interestRateMode;\n  address assetAddress;\n  uint8 v;\n  bytes32 r;\n  bytes32 s;\n}\n\n// AaveBorrowAction specific arguments\nstruct AaveBorrowActionArgs {\n  uint256 amount;\n  uint256 interestRateMode;\n  Asset asset;\n  bool amountIsPercent;\n  uint16 referralCode;\n}\n\ncontract AaveBorrowAction is IWorkflowStep, IWorkflowStepBeforeAll, IWorkflowStepAfterAll {\n  // prices from Aave oracle have 8 decimals\n  // so to convert to float we need to divide by 1e8\n  uint256 internal constant AAVE_ORACLE_PRICE_DIVISOR_UINT = 100000000;\n  uint256 internal constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n  address public immutable poolAddressProviderAddress;\n  address public immutable wethAddress;\n  bytes16 internal immutable AAVE_ORACLE_PRICE_DIVISOR_FLOAT;\n  bytes16 internal immutable TEN_FLOAT;\n\n  event Eraseme(address debtToken, uint256 amount, uint256 interestRateMode, address assetAddress, uint8 v, bytes32 r, bytes32 s);\n\n  constructor(address _poolAddressProviderAddress, address _wethAddress) {\n    poolAddressProviderAddress = _poolAddressProviderAddress;\n    wethAddress = _wethAddress;\n    AAVE_ORACLE_PRICE_DIVISOR_FLOAT = ABDKMathQuad.fromUInt(AAVE_ORACLE_PRICE_DIVISOR_UINT);\n    TEN_FLOAT = ABDKMathQuad.fromUInt(10);\n  }\n\n  function execute(AssetAmount[] calldata, bytes calldata argData) public payable returns (WorkflowStepResult memory) {\n\n\n    // Locals memory locals;\n\n    AaveBorrowActionArgs memory args = abi.decode(argData, (AaveBorrowActionArgs));\n\n\n\n\n\n\n\n    uint256 borrowAmount = args.amount;\n\n\n    // {\n    //   // IPriceOracleSentinel priceOracleSentinel = IPriceOracleSentinel(poolAddressProvider.getPriceOracleSentinel());\n\n    //   // require(priceOracleSentinel.isBorrowAllowed(), 'borrow is not allowed');\n    // }\n\n    IPool pool = getPool();\n    address assetAddress = args.asset.assetType == AssetType.ERC20 ? args.asset.assetAddress : wethAddress;\n    if (args.amountIsPercent) {\n      borrowAmount = computeRelativeAmount(args.amount, assetAddress, pool);\n    }\n\n\n    // ICreditDelegationToken debtToken;\n    // {\n    //   DataTypes.ReserveData memory reserveData = pool.getReserveData(assetAddress);\n    //   if (args.interestRateMode == 1) {\n    //     debtToken = ICreditDelegationToken(reserveData.stableDebtTokenAddress);\n    //   } else {\n    //     debtToken = ICreditDelegationToken(reserveData.variableDebtTokenAddress);\n    //   }\n    // }\n    // // the first sig is to delegate max uint to this\n\n\n    // debtToken.delegationWithSig(\n    //   msg.sender,\n    //   address(this),\n    //   MAX_UINT256,\n    //   MAX_UINT256,\n    //   args.delegateSignatures[0].v,\n    //   args.delegateSignatures[0].r,\n    //   args.delegateSignatures[0].s\n    // );\n\n\n\n\n\n\n\n\n\n    pool.borrow(assetAddress, borrowAmount, args.interestRateMode, args.referralCode, msg.sender);\n\n    // the second sig is to delegate 0 to this\n\n    // debtToken.delegationWithSig(\n    //   msg.sender,\n    //   address(this),\n    //   0,\n    //   MAX_UINT256,\n    //   args.delegateSignatures[1].v,\n    //   args.delegateSignatures[1].r,\n    //   args.delegateSignatures[1].s\n    // );\n\n\n    if (args.asset.assetType == AssetType.Native) {\n\n      IWeth(wethAddress).withdraw(borrowAmount);\n    }\n\n    return LibStepResultBuilder.create(0, 1).addOutputAssetAmount(AssetAmount(args.asset, borrowAmount)).result;\n  }\n\n  function computeRelativeAmount(uint256 borrowAmountPercent, address assetAddress, IPool pool) internal view returns (uint256) {\n\n    // get borrowing power (in base currency)\n    uint256 availableBorrowsBase;\n    {\n      uint256 totalCollateralBase;\n      uint256 totalDebtBase;\n      uint256 currentLiquidationThreshold;\n      uint256 ltv;\n      uint256 healthFactor;\n\n      (totalCollateralBase, totalDebtBase, availableBorrowsBase, currentLiquidationThreshold, ltv, healthFactor) = pool.getUserAccountData(\n        msg.sender\n      );\n    }\n\n\n    // take percentage of borrowing power (in base currency)\n    uint256 borrowAmountBase = LibPercent.percentageOf(availableBorrowsBase, borrowAmountPercent);\n\n\n    // ask the price oracle for the price of the asset to be borrowed\n    uint256 assetPrice;\n    {\n      IPoolAddressesProvider poolAddressProvider = IPoolAddressesProvider(poolAddressProviderAddress);\n      IAaveOracle aaveOracle = IAaveOracle(poolAddressProvider.getPriceOracle());\n      address[] memory addresses = new address[](1);\n      addresses[0] = assetAddress;\n      assetPrice = aaveOracle.getAssetsPrices(addresses)[0];\n\n    }\n\n\n    uint8 decimals = IERC20Metadata(assetAddress).decimals();\n\n\n    // use floats to compute the amount of the asset to be borrowed\n    bytes16 borrowAmountFloat;\n    {\n      bytes16 assetPriceFloat = ABDKMathQuad.fromUInt(assetPrice).div(AAVE_ORACLE_PRICE_DIVISOR_FLOAT);\n      bytes16 borrowAmountBaseFloat = ABDKMathQuad.fromUInt(borrowAmountBase).div(AAVE_ORACLE_PRICE_DIVISOR_FLOAT);\n      borrowAmountFloat = borrowAmountBaseFloat.div(assetPriceFloat);\n    }\n\n    bytes16 scaler = ABDKMathQuad.fromUInt(10 ** decimals);\n    borrowAmountFloat = borrowAmountFloat.mul(scaler);\n    return borrowAmountFloat.toUInt();\n  }\n\n  function beforeAll(bytes calldata argData) external payable {\n\n    invokeDelegateWithSigs(argData);\n  }\n\n  function afterAll(bytes calldata argData) external payable {\n\n    invokeDelegateWithSigs(argData);\n  }\n\n  function invokeDelegateWithSigs(bytes calldata argData) internal {\n    DelegationWithSignatureArgs[] memory args = abi.decode(argData, (DelegationWithSignatureArgs[]));\n    IPool pool = getPool();\n    for (uint256 i = 0; i < args.length; i++) {\n\n      ICreditDelegationToken debtToken = getDebtToken(pool, args[i].assetAddress, args[i].interestRateMode);\n      emit Eraseme(address(debtToken), args[i].amount, args[i].interestRateMode, args[i].assetAddress, args[i].v, args[i].r, args[i].s);\n      debtToken.delegationWithSig(msg.sender, address(this), args[i].amount, MAX_UINT256, args[i].v, args[i].r, args[i].s);\n    }\n  }\n\n  function getPool() internal view returns (IPool) {\n    IPoolAddressesProvider poolAddressProvider = IPoolAddressesProvider(poolAddressProviderAddress);\n    address poolAddress = poolAddressProvider.getPool();\n    return IPool(poolAddress);\n  }\n\n  function getDebtToken(IPool pool, address assetAddress, uint256 interestRateMode) internal view returns (ICreditDelegationToken) {\n    DataTypes.ReserveData memory reserveData = pool.getReserveData(assetAddress);\n    if (interestRateMode == 1) {\n      return ICreditDelegationToken(reserveData.stableDebtTokenAddress);\n    }\n    return ICreditDelegationToken(reserveData.variableDebtTokenAddress);\n  }\n\n  // there are just here for unit testing to enable weth.withdraw()\n  receive() external payable {}\n\n  fallback() external payable {}\n}\n"
    },
    "contracts/AaveRepayAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/IWorkflowStep.sol';\nimport '@freemarket/core/contracts/model/AssetAmount.sol';\nimport '@freemarket/core/contracts/LibPercent.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@freemarket/step-sdk/contracts/LibStepResultBuilder.sol';\nimport '@freemarket/step-sdk/contracts/LibErc20.sol';\nimport '@freemarket/step-sdk/contracts/LibWethUtils.sol';\nimport '@freemarket/step-sdk/contracts/ABDKMathQuad.sol';\nimport '@freemarket/step-sdk/contracts/IWeth.sol';\n\nimport '@freemarket/core/contracts/model/WorkflowStepInputAsset.sol';\nimport '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport '@aave/core-v3/contracts/interfaces/IPriceOracleSentinel.sol';\nimport '@aave/core-v3/contracts/interfaces/IAaveOracle.sol';\nimport '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport '@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol';\n\nusing LibStepResultBuilder for StepResultBuilder;\nusing LibErc20 for IERC20;\nusing ABDKMathQuad for bytes16;\n\n// AaveBorrowAction specific arguments\nstruct AaveRepayActionArgs {\n  uint256 interestRateMode;\n}\n\ncontract AaveRepayAction is IWorkflowStep {\n  address public immutable poolAddressProviderAddress;\n  address public immutable wethAddress;\n\n  constructor(address _poolAddressProviderAddress, address _wethAddress) {\n    poolAddressProviderAddress = _poolAddressProviderAddress;\n    wethAddress = _wethAddress;\n  }\n\n  function execute(AssetAmount[] calldata inputAssets, bytes calldata argData) public payable returns (WorkflowStepResult memory) {\n\n    require(inputAssets.length == 1, 'there must be exactly 1 input asset');\n\n    address assetAddress;\n    if (inputAssets[0].asset.assetType == AssetType.Native) {\n\n      IWeth(wethAddress).deposit{value: inputAssets[0].amount}();\n      assetAddress = wethAddress;\n    } else {\n      assetAddress = inputAssets[0].asset.assetAddress;\n    }\n    AaveRepayActionArgs memory args = abi.decode(argData, (AaveRepayActionArgs));\n\n\n\n\n    IPoolAddressesProvider poolAddressProvider = IPoolAddressesProvider(poolAddressProviderAddress);\n    address poolAddress = poolAddressProvider.getPool();\n    IPool pool = IPool(poolAddress);\n\n    IERC20(assetAddress).approve(poolAddress, inputAssets[0].amount);\n    pool.repay(assetAddress, inputAssets[0].amount, args.interestRateMode, msg.sender);\n    return LibStepResultBuilder.create(1, 0).addInputAssetAmount(inputAssets[0]).result;\n  }\n}\n"
    },
    "contracts/AaveSupplyAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/IWorkflowStep.sol';\nimport './IAaveV3Pool.sol';\nimport '@freemarket/core/contracts/model/AssetAmount.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@freemarket/step-sdk/contracts/LibStepResultBuilder.sol';\nimport '@freemarket/step-sdk/contracts/LibErc20.sol';\nimport '@freemarket/step-sdk/contracts/LibWethUtils.sol';\n\n\nusing LibStepResultBuilder for StepResultBuilder;\nusing LibErc20 for IERC20;\n\ncontract AaveSupplyAction is IWorkflowStep {\n  address public immutable poolAddress;\n  address public immutable wethAddress;\n\n  /// @notice This event is emitted when an Aave 'supply' action is executed.\n  /// @param inputAssetAmount the asset and amout being supplied to Aave.\n  event AaveSupplyActionEvent(AssetAmount inputAssetAmount);\n\n  constructor(address _aavePoolAddress, address _wethAddress) {\n    poolAddress = _aavePoolAddress;\n    wethAddress = _wethAddress;\n  }\n\n  struct Locals {\n    IERC20 inputToken;\n    address inputTokenAddress;\n    IAaveV3Pool pool;\n    IERC20 aToken;\n    uint256 aTokenBalanceBefore;\n    uint256 aTokenBalanceAfter;\n    ReserveData reserveData;\n  }\n\n  function execute(AssetAmount[] calldata assetAmounts, bytes calldata) public payable returns (WorkflowStepResult memory) {\n\n    // validate\n    require(assetAmounts.length == 1, 'there must be exactly 1 input asset');\n\n    emit AaveSupplyActionEvent(assetAmounts[0]);\n    Locals memory locals;\n\n\n\n    locals.inputTokenAddress = LibWethUtils.wrapIfNecessary(assetAmounts[0], wethAddress);\n\n\n    // approve aave to take the asset\n    locals.inputToken = IERC20(locals.inputTokenAddress);\n\n\n\n    locals.inputToken.safeApprove(poolAddress, assetAmounts[0].amount);\n\n    // get the aToken\n    locals.pool = IAaveV3Pool(poolAddress);\n    locals.reserveData = locals.pool.getReserveData(locals.inputTokenAddress);\n\n    // invoke supply\n\n    locals.pool.supply(locals.inputTokenAddress, assetAmounts[0].amount, msg.sender, 0);\n\n    return\n      // since the asset is going straight to the caller, it's not counted as an asset 'in the workflow'\n      // but still mentioning it here with a 0 amount so it gets logged\n      LibStepResultBuilder\n        .create(1, 0, 1)\n        .addInputAssetAmount(assetAmounts[0])\n        .addOutputAssetAmountToCaller(AssetAmount(Asset(AssetType.ERC20, locals.reserveData.aTokenAddress), assetAmounts[0].amount))\n        .result;\n  }\n}\n"
    },
    "contracts/IAaveV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nstruct UserConfigurationMap {\n  /**\n   * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n   * The first bit indicates if an asset is used as collateral by the user, the second whether an\n   * asset is borrowed by the user.\n   */\n  uint256 data;\n}\n\nstruct ReserveConfigurationMap {\n  //bit 0-15: LTV\n  //bit 16-31: Liq. threshold\n  //bit 32-47: Liq. bonus\n  //bit 48-55: Decimals\n  //bit 56: reserve is active\n  //bit 57: reserve is frozen\n  //bit 58: borrowing is enabled\n  //bit 59: stable rate borrowing enabled\n  //bit 60: asset is paused\n  //bit 61: borrowing in isolation mode is enabled\n  //bit 62-63: reserved\n  //bit 64-79: reserve factor\n  //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n  //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n  //bit 152-167 liquidation protocol fee\n  //bit 168-175 eMode category\n  //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n  //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n  //bit 252-255 unused\n\n  uint256 data;\n}\n\nstruct ReserveData {\n  //stores the reserve configuration\n  ReserveConfigurationMap configuration;\n  //the liquidity index. Expressed in ray\n  uint128 liquidityIndex;\n  //the current supply rate. Expressed in ray\n  uint128 currentLiquidityRate;\n  //variable borrow index. Expressed in ray\n  uint128 variableBorrowIndex;\n  //the current variable borrow rate. Expressed in ray\n  uint128 currentVariableBorrowRate;\n  //the current stable borrow rate. Expressed in ray\n  uint128 currentStableBorrowRate;\n  //timestamp of last update\n  uint40 lastUpdateTimestamp;\n  //the id of the reserve. Represents the position in the list of the active reserves\n  uint16 id;\n  //aToken address\n  address aTokenAddress;\n  //stableDebtToken address\n  address stableDebtTokenAddress;\n  //variableDebtToken address\n  address variableDebtTokenAddress;\n  //address of the interest rate strategy\n  address interestRateStrategyAddress;\n  //the current treasury balance, scaled\n  uint128 accruedToTreasury;\n  //the outstanding unbacked aTokens minted through the bridging feature\n  uint128 unbacked;\n  //the outstanding debt borrowed against this asset in isolation mode\n  uint128 isolationModeTotalDebt;\n}\n\n/**\n * @title IAaveV3Pool\n * @author FreeMarketProtocol\n * @notice This is a _partial_ interface with only the supply method used by AaveSupplyAction.\n */\ninterface IAaveV3Pool {\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (ReserveData memory);\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external returns (uint256);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user) external view returns (UserConfigurationMap memory);\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n}\n"
    },
    "contracts/MockAavePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './IAaveV3Pool.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n// import '../../mocks/MockToken.sol';\nimport '@freemarket/step-sdk/contracts/TestErc20.sol';\n\ncontract MockAavePool is IAaveV3Pool {\n  TestErc20 public immutable mockAToken = new TestErc20('aUSDC', 6);\n\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external {\n    // take the asset being supplied, and mint some aToken (equal amounts of each)\n    IERC20(asset).transferFrom(msg.sender, address(this), amount);\n    mockAToken.mint(onBehalfOf, amount);\n    emit Supply(asset, msg.sender, onBehalfOf, amount, referralCode);\n  }\n\n  function getReserveData(address) external view returns (ReserveData memory) {\n    return ReserveData(ReserveConfigurationMap(0), 0, 0, 0, 0, 0, 0, 0, address(mockAToken), address(0), address(0), address(0), 0, 9, 0);\n  }\n\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    override\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {}\n\n  function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external override {}\n\n  function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf) external override returns (uint256) {}\n\n  function getUserConfiguration(address user) external view override returns (UserConfigurationMap memory) {}\n\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external override {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}