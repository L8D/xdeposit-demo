use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};
use spl_associated_token_account::get_associated_token_address;
// use spl_associated_token_account::instruction::create_associated_token_account;

pub type Address = [u8; 32];
pub type ChainID = u16;
pub type ForeignAddress = [u8; 32];

// devnet core bridge 3u8hJUVTA4jH1wYAyUur7FFZVQ8H635K3tSHHF4ssjQ5
#[cfg(feature = "devnet")]
const CORE_BRIDGE_ADDRESS: [u8; 32] = [
    0x2b, 0x12, 0x46, 0xc9, 0xee, 0xfa, 0x3c, 0x46, 0x67, 0x92, 0x25, 0x31, 0x11, 0xf3, 0x5f, 0xec,
    0x1e, 0xe8, 0xee, 0x5e, 0x9d, 0xeb, 0xc4, 0x12, 0xd2, 0xe9, 0xad, 0xad, 0xfe, 0xcd, 0xcc, 0x72,
];

const CORE_BRIDGE_PUBKEY: Pubkey = Pubkey::new_from_array(CORE_BRIDGE_ADDRESS);

#[derive(BorshDeserialize, BorshSerialize, Default, Debug)]
pub struct WormholeTransfer {
    pub fee_collector_account: Pubkey, // sent because I can't figure out how to read it on-chain
    pub nonce: u32,                    // hard to generate random numbers on-chain
    pub from: Pubkey,                  // from address (users main wallet addr)
    pub payer: Pubkey,                 // I think payer can pay feeds instead so probably not needed
    // pub amount: u64,  // filled in by workflow engine logic
    pub target_address: Address,
    pub target_chain: ChainID,
    // pub message_key: Pubkey,  I think this can be generated by wfe
    pub token_address: Pubkey, // or should it be ForeignAddress,
    pub token_chain: u16,

    // below probably not needed
    pub from_owner: Pubkey, // forget what this is
    pub fee: u64,           // fee to relayers
}

pub fn wormhole(bits: &Vec<u8>, amount: u64) {
    let x = WormholeTransfer::try_from_slice(&bits).unwrap();

    msg!("nonce {}", x.nonce);
    // msg!("program_id {}", x.program_id);
    // msg!("bridge_id {}", x.bridge_id);
    // msg!("payer {}", x.payer);
    // msg!("from {}", x.from);

    // msg!("target_chain {}", x.target_chain);
    // msg!("token_chain {}", x.token_chain);
    // msg!("from_owner {}", x.from_owner);

    msg!("fee {}", x.fee);
    // msg!("wormholeTransfer: {:#?}", x)

    let associated_address = get_associated_token_address(&x.from, &x.token_address);
    msg!("got associated address {}", associated_address);

    // let _result = spl_token::instruction::approve(
    //     &x.from,
    //     &x.payer,
    //     &x.bridge_id,
    //     &x.from_owner,
    //     &[&x.from_owner],
    //     amount,
    // );
    msg!("leaving wormhole")
}
