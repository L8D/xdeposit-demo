use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize, BorshSchema};

declare_id!("F1EJHnyEDWfbTs1bM36an7szd8ftuXJZHL4oFw9mxaiZ");

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct WorkflowStep {
    pub step_id: u16,
    pub data: Vec<u8>
}


pub mod wh {
    use super::*;

    pub type Address = [u8; 32];
    pub type ChainID = u16;
    pub type ForeignAddress = [u8; 32];

    #[derive(BorshDeserialize, BorshSerialize, BorshSchema, Default, Debug)]
    pub struct WormholeTransfer {
        pub nonce: u32,
        pub program_id: Pubkey,
        pub bridge_id: Pubkey,
        pub payer: Pubkey,
        pub from: Pubkey,  // from address or mint address?
        // pub amount: u64,
        // pub target_address: Address,
        // pub target_chain: ChainID,
        // // pub message_key: Pubkey,  I think this can be generated by wfe
        // pub token_address: ForeignAddress,
        // pub token_chain: u16,
        // pub from_owner: Pubkey,
        pub fee: u64
    }


    pub fn wormhole(bits: &Vec<u8>)  {
        let x = WormholeTransfer::try_from_slice(&bits).unwrap();
        msg!("nonce {}", x.nonce);
        msg!("program_id {}", x.program_id);
        msg!("bridge_id {}", x.bridge_id);
        msg!("payer {}", x.payer);
        msg!("from {}", x.from);
        msg!("fee {}", x.fee);
        // Ok(())
    }

}

#[program]
pub mod fmp {   
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }


    pub fn execute_workflow(ctx: Context<UserAccount>, steps: Vec<WorkflowStep>) -> Result<()> {
        msg!("hi");
        msg!("{} steps", steps.len());
        msg!("steps.0.step_id: {}", steps[0].step_id);
        msg!("steps.0.data.len(): {}", steps[0].data.len());
        for i in 0..steps[0].data.len() {
            msg!("steps.0.data[{}]={}", i, steps[0].data[i]);
        }
        wh::wormhole(&steps[0].data);
        Ok(())
    }

}




#[derive(Accounts)]
pub struct Initialize {}

#[derive(Accounts)]
pub struct UserAccount {}
